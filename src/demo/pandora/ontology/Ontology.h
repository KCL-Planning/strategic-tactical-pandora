#ifndef DEMO_PANDORA_ONTOLOGY_ONTOLOGY_H
#define DEMO_PANDORA_ONTOLOGY_ONTOLOGY_H

#include <vector>
#include <time.h>

#include <ros/ros.h>

#include <glm/glm.hpp>

#include <planning_msgs/GetSubTypes.h>
#include <planning_msgs/GetInstancesOfType.h>
#include <planning_msgs/GetAttributesOfType.h>
#include <planning_msgs/GetAttributesOfInstance.h>
#include <planning_msgs/CompletePlan.h>

#include <knowledge_msgs/Filter.h>
#include <knowledge_msgs/RoadmapRefresh.h>
#include <knowledge_msgs/KnowledgeInterface.h>

#include "OctomapUpdateListener.h"
#include "Pose.h"
#include "OntologyInterface.h"
#include "../RRTUpdateListener.h"

class InspectionPoint;
class RRT;
class Filter;
class Waypoint;
class OctomapBuilder;

/**
 * Class to mimic the ontology module that provides the planner with waypoints, etc.
 */
class Ontology : public OntologyInterface//, public OctomapUpdateListener, public RRTUpdateListener
{
public:
	/**
	 * Create an ontology interface that contains all the information that are relevant to the planner.
	 * @param ros_node The ros node.
	 * @param octomap_builder The octomap that is maintained.
	 */
	Ontology(ros::NodeHandle& ros_node, OctomapBuilder& octomap_builder);
	
	/**
	 * Callback function for when the planner wants to request information from the ontology.
	 */
	bool getKnowledge(knowledge_msgs::KnowledgeInterface::Request& req, knowledge_msgs::KnowledgeInterface::Response& res);

	/**
	 * Get all the inspection points stored in the ontology.
	 * @param inspection_points The vector where all found inspection points will be added to.
	 * @return True if the data could be retreived from the ontology, false otherwise.
	 */
	bool getInspectionPoints(std::vector<InspectionPoint*>& inspection_points);
	
	/**
	 * Set the pillar of the given inspection point as observed (if there is a pillar associated with it.
	 */
	void observedInspectionPoint(const glm::vec3& inspection_point);
	
	/**
	 * Get the waypoint associated with the given waypoint, normally the waypoints are stored in the RRT,
	 * but some waypoints are special. The the waypoint does not start with a 'W' it means it is related to
	 * a structure. Every structure has a special waypoint that is at the top centre of that structure. The
	 * name for those is "L<structure id>", L stands for "Leave me alone, it works mofo!".
	 * @param waypoint_name Either starts with an W, in which case it is a waypoint generated by the RRT or
	 * it starts with an L in which case it is a waypoint associated with a mission site.
	 * @return The waypoint requested, this should NEVER be NULL.
	 */
	Waypoint* getWaypoint(const std::string& waypoint_name) const;
	
private:
	/**
	 * Helper functions to get information out of the ontology.
	 */
	bool GetInstancesOfType(knowledge_msgs::KnowledgeInterface::Request& req, knowledge_msgs::KnowledgeInterface::Response& res);
	bool GetAttributesOfInstance(knowledge_msgs::KnowledgeInterface::Request& req, knowledge_msgs::KnowledgeInterface::Response& res);
	
	/**
	 * This is the callback function whenever a new filter is requested. The message contains all the relevant information for the
	 * filter, check @ref{knowledge_msgs::Filter} for more information. If one of the filters is violated a notificaction is send out.
	 *
	void updateFilter(const knowledge_msgs::Filter::ConstPtr& msg);
	*/
	
	/**
	 * Every time a new plan is generated, this method is called.
	 * @param plan The new action sequence of the current plan.
	 */
	void setCurrentPlan(const planning_msgs::CompletePlan::ConstPtr& msg);
	
	/**
	 * Auxillery function that resolved the inspection point instance given the name of it.
	 * @param inspection_point_name The name of the inspection point as it is stored in the ontology (W#, where # is its number).
	 * @return The inspection point associated with the given name, NULL is no such inspection point exists (this should never happen!).
	 */
	InspectionPoint& getInspectionPoint(const std::string& inspection_point_name);
	
	ros::NodeHandle* ros_node_; /// The ros node.
	ros::ServiceServer ontology_server_; /// Service which exposes information in the ontology.
	ros::Subscriber complete_plan_listener_; /// Listen to messages that contain the complete current plan.
};

#endif
